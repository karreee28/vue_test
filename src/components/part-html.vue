<template>

  <section class="wrap">
    <h2>HTML, CSS</h2>
    <article>
      <p><b>&lt;section&gt;과 &lt;div&gt;, &lt;header&gt;, &lt;footer&gt;, &lt;article&gt; 엘리먼트의 차이점은 무엇인가요?</b>
      기본적인 스타일 속성은 같지만 내용이나 용도에 따라 구분하여 사용. 대체적으로 section은 내용의 구조를 만들 때, article은 페이지의 내용과 관련이 없는 독립적인 경우일 때 사용함.<br>
      <strong>Section</strong> : 내부 콘텐츠가 그룹화되어 페이지 개요에 항목으로 표시되어야 하는 요소<br>
      <strong>Header</strong> : 도입부에 해당하는 콘텐츠를 가지고 있는 부분<br>
      <strong>Footer</strong> : 사이트의 작성자나 저작권정보, 연락처 등의 정보를 담고 있는 부분<br>
      <strong>Article</strong> : html 문서에서 독립적인 하나의 기사로, 아티클 요소의 내용 자체만으로도 내용이 이해가 되어야 함<br>
      <strong>div</strong> : 별다른 의미 전달을 하지 않음<br>
      div외 나머지 요소들은 레이아웃만을 위한 시맨틱 태그로, 태그 스스로 브라우저와 개발자 모두에게 자신이 사용된 의미를 명확히 전달해 줌</p>
      <p><b>블럭 레벨 엘리먼트와 인라인 엘리먼트의 차이는 무엇일까요?</b>
      블럭은 기본적으로 가로 폭을 모두 사용하고 width, height 사이즈 조절이나 padding 등의 여백 속성이 적용 가능하며 블럭 엘리먼트 안에 다른 블럭이나 인라인 엘리먼트 포함 가능.<br>
      인라인은 내용이 차지하는 영역만 사용하고 사이즈 조절이나 여백 속성은 적용할 수 없으며 안에 인라인 엘리먼트만 포함 가능.<br>
      블럭요소 : 줄바꿈이 일어나는 요소 (h1,p,div 등), 블럭, 인라인 요소 포함 가능<br>
      인라인 요소 : 줄바꿈이 없는 요소 (span, em, strong, a 등), 블럭요소 포함 불가능</p>
      <p><b>시맨틱 웹(Semantic Web) 이 뭔가요?</b>
      검색엔진이나 AI 등의 컴퓨터가 자동으로 헤더나 푸터, 컨텐츠 영역의 구조를 파악 할 수 있는 웹. 시멘틱 태그인 header나 nav, footer 등을 사용하여 제작.<br>
      기계가 사람을 대신해서 웹 페이지의 정보를 이해하고, 우리에게 필요한 정보만 보여주거나 정보를 가공해서 우리가 필요로 하는 형태로 가공해주는 것으로 스스로 의미를 갖는 시멘틱 태그를 사용하여 작성된 웹 페이지</p>
    </article>
    <article>
      <p><b>* CSS를 HTML에 적용하는 세 가지 방법과 장단점</b>
      <strong>* Inline Style</strong><br>
      해당 태그 요소에만 스타일 적용. 우선순위가 가장 높음.<br>
      어떤 스타일을 적용 했는 지 알기는 쉽지만 2개 이상의 공통 스타일의 적용에는 비효율적.<br>
      <strong>방법</strong> : 특정태그에만 스타일을 적용하고 싶을 때 사용<br>
      <strong>장점</strong> : 1회용으로 하나의 태그에만 스타일을 적용 할 때 유용<br>
      <strong>단점</strong> : 향후 스타일 변경 시 해당되는 모든 태그에 적용된 스타일을 일일이 변경해주어야 하여 유지보수가 어렵다<br>
      <strong>* &lt;style&gt;</strong><br>
      해당 페이지에만 스타일 적용. 우선순위는 Inline Style 다음.<br>
      해당 페이지 내에서는 2개 이상의 공통 스타일 요소의 적용이 가능하지만 페이지가 많아지면 비효율적.<br>
      <strong>방법</strong> : 페이지 상단에 적용하는 방식으로 한 문서에만 해당되는 스타일을 지정할때 사용<br>
      <strong>장점</strong> : 스타일을 여러번 재사용 가능<br>
      <strong>단점</strong> : 현재 페이지에서만 사용 가능하여 전체적인 사이트 스타일 변경 시 페이지 마다 변경 해주어야 함<br>
      <strong>* &lt;link rel="stylesheet" href="..."&gt;</strong><br>
      외부 스타일 시트 파일 연결. 우선순위가 가장 낮음.<br>
      사이트의 모든 페이지에 동일한 스타일을 적용 가능하여 유지 보수가 편하지만 가독성이 낮고 로딩 속도와 같은 성능 면에서는 좋지 않음.<br>
      <strong>방법</strong> : 별도의 파일(.css)을 만들어서 적용하는 방식으로 모든 페이지에 공통으로 적용해야할 때 사용<br>
      <strong>장점</strong> : 사이트 전체의 스타일을 일관성있게 유지, 변경 시 일괄적으로 변경되어 유지보수 측면에서 편리함<br>
      <strong>단점</strong> : 파일을 계속적으로 관리해주면서 HTML 문서를 만들어 나가야 하기에 불편</p>

      <p><b>* float 속성은 왜 좋지 않을까요?</b>
      강제로 요소를 띄워버리기 때문에 부모 요소가 자식 요소의 높이값을 인식 못함. clear를 사용해 float를 초기화 시키는 등의 추가 작업이 필요함.
      플로트 박스를 포함하고 있는 부모 요소가 플로트 박스의 높이를 알 수 없기 때문에 레이아웃이 틀어지는 경우가 많고, 연성이 다소 떨어짐
      플로트 박스 이후에는 플로트 박스를 해지하는 스타일을 지정해줘야 하며 부모 요소의 너비에 따라 자식 요소의 너비를 계산해줘야 하는 유지보수 측면의 불편 등
      사용하기 위한 필요요소가 많고 유연성이 다소 떨어짐</p>

      <p><b>Flexbox(Flexible box)와 CSS Grid의 차이와 장단점은 무엇일까요?</b>
      Flexbox는 1개의 행(row)의 레이아웃을 적용할 때 하위 요소들을 정렬하기에 간편하지만 행이 여러 개가 되면 첫 행의 속성을 다른 행이 그대로 가지기 때문에 다양한 레이아웃을 그리기 힘듦.<br>
      Grid는 여러 행의 레이아웃을 적용할 때 하위 요소 정렬에 효율적이고 간편하게 최적화 되어 있으나 브라우저 호환이 잘 안돼 크로스 브라우징이 어려움.<br>
      레이아웃을 다룰 때 한 번에 하나의 행이나 열만을 다루어 1차원이지만 그리드는 레이아웃 짜는데에 좀 더 유연하며 자유로워 2차원이라교 표현됨<br>
      <strong>Flexbox 장점</strong> : 크기를 유연하게 조절할 수 있음, 마크업 순서와 별개로 동작하기 때문에 접근성에 제약을 받지 않음<br>
      <strong>Flexbox 단점</strong> : 1차원 레이아웃이기 때문에 행 마다 새로운 플렉스 컨테이너를 선언하거나, 여러 속성을 복잡하게 계산해 활용해야 함, ie 브라우저의 지원이 제한적<br>
      <strong>Grid 장점</strong> : 2차원 레이아웃이기 때문에 요소를 화면 크기에 따라 재정의가 가능하여 좀 더 세밀한 반응형 디자인이 가능<br>
      <strong>Grid 단점</strong> : ie 브라우저의 지원이 제한적</p>
    </article>

    <article>
      <p><b>* 브라우저가 브라우저의 윈도우 화면에 DOM을 생성하는 과정은 내부적으로 어떻게 진행되나요?</b>
      html 파싱 → 렌더 트리 구축 → 렌더 트리 배치 → 렌더 트리 그리기 순으로 진행.<br>
      렌더 트리는 문서(DOM)의 상단에서 하단으로 순차적으로 진행하며 렌더 요소의 CSS(CSSOM)를 찾아 불러 옴.<br>
      head태그나 display: none, hidden은 렌더 트리에 포함되지 않음(visibility: hidden은 공간을 차지한 채로 보이지 않을 뿐이라 렌더 트리에 포함).<br>
      변환 > 토큰화 > 렉싱 > DOM 생성<br>
      <strong>1. 변환</strong> : HTML의 원시 바이트를 디스크나 네트워크에서 읽어와서, 해당 파일에 대해 지정된 인코딩에 따라 개별 문자로 변환<br>
      <strong>2. 토큰화</strong> : 브라우저가 문자열을 W3C HTML5 표준에 지정된 고유 토큰으로 변환<br>
      <strong>3. 렉싱</strong> : 방출된 토큰은 해당 속성 및 규칙을 정의하는 '객체'로 변환<br>
      <strong>4. DOM 생성</strong> : HTML 마크업이 여러 태그간의 관계를 정의하기 때문에 생성된 객체는 트리 데이터 구조 내에 연결</p>
      <p><b>크롬, 사파리, 익스플로러의 렌더링 엔진은 어떤 것입니까?</b>
      <strong>크롬</strong> : 블링크<br>
      <strong>사파리</strong> : 웹킷<br>
      <strong>익스플로러</strong> : 트라이던트</p>
    </article>
    <article>
      <p><b>* MVC는 무엇이고 왜 나타났나요?</b>
      Model(데이터와 로직), View(레이아웃과 화면), Controller(모델과 뷰를 컨트롤).<br>
      뷰가 모델로부터 데이터를 받고 컨트롤러가 입력을 받아 뷰와 모델을 컨트롤. 각 영역을 분리하여 개발 및 유지보수를 효율적으로 진행하기 위해 정함.<br>
      Model View Controller의 약자로 하나의 애플리케이션, 프로젝트를 구성할 때 그 구성요소를 세가지의 역할로 구분한 패턴<br>
      어떤 특정한 역할들에 대해 역할분담을 할 때 가이드라인을 제시</p>
      <p><b>* MVVM은 무엇이고 왜 나타났나요?</b>
      Model, View, ViewModel(View와 데이터바인딩<자동갱신> - 모델과 데이터를 주고 받음).<br>
      다른 패턴은 모델과 뷰의 높은 의존성 때문에 유지보수가 어려워 정함. 비교적 모델과 뷰의 상호 의존성이 낮아 테스트와 모듈화가 쉬움.<br>
      Model - View - ViewModel의 약자, 디자이너가 작업한 인터페이스 (실질적인 사용자들이 눈으로 볼 수 있는 페이지) 가 View 에 해당하고,<br>
      Database 와 통신하는 역할을 Model 이 담당하며 둘 사이에서,<br>
      View 와는 Binding 이나 Command 로 연결하고 Model 과는 데이터를 주고 받는 역할을 담당하는 녀석이 ViewModel<br>
      모든 비즈니스 논리와 GUI 환경설정이 명백하게 분리된 마틴 파울러의 프레젠테이션 모델 디자인 패턴을 특수화하기 위해</p>
      <p><b>* MVVM을 지향하는 자바스크립트 프레임워크에는 무엇이 있나요?</b>
      Knockout.js, Angular, React, vue.js 등</p>
    </article>
  </section>
</template>

<script>
export default {
  name: 'PartHTML',
  components: { },
  data () {
    return { //데이터 값이 없어도 리턴 필수

    }
  },
  methods: {

  }
};
</script>
<style type="text/css">



</style>
